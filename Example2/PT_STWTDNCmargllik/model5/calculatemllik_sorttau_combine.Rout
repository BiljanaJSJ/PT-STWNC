
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #sort the samples [theta, tau | Y] by tau using N=up-low samples
> #get M<N unique tau slices 
> #sum_i_{1_M} sum_j_{1_ni} log(P(Y | theta_i_j)) [ti+1-ti]
> 
> source('ST_Galaxy_functions.R')
> source('ST_Galaxy_runST.R')
> 
> library(MASS)
> library(MCMCpack)
Loading required package: coda
##
## Markov Chain Monte Carlo Package (MCMCpack)
## Copyright (C) 2003-2017 Andrew D. Martin, Kevin M. Quinn, and Jong Hee Park
##
## Support provided by the U.S. National Science Foundation
## (Grants SES-0350646 and SES-0350613)
##
> library(truncnorm)
> 
> 
> mllik=rep(NA,10)
> mean_se=rep(NA,10)
> 
> 
> mllik=rep(NA,10)
> mean_se=rep(NA,10)
> #n=25
> low=1000
> up=35000
> 
> for (i in (1:10)){
+   
+   out_ls=get(load(paste('mllik',i,'.RData',sep='')))
+ 
+   tau_samples=c(out_ls$tau[low:up],rep(1,length(out_ls$tau[low:up])))
+   mloglik_samples=c(out_ls$mllik[[1]][low:up],out_ls$mllik[[2]][low:up])
+ 
+ 
+   indxSortedtau=sort(tau_samples,index=T)
+   
+   SortedThetaTau= tau_samples[indxSortedtau$ix]
+   #SortedThetaTau[which(is.na(SortedThetaTau))]=1
+   
+   uniqueTau=c(0,unique(SortedThetaTau))
+   tau_int=diff(uniqueTau)
+   
+   #ind=which(out_ls$PT_chain[[1]][,2]==uniqueTau[1])
+   #out_ls$mllik[[1]][ind]*tau_int[1]
+   
+   indicesUniqueTau=lapply(1:length(uniqueTau),function(x){ which(tau_samples==uniqueTau[x]) })
+   
+   ThermodynIntergal=lapply(1:length(uniqueTau),function(x){ mean(mloglik_samples[indicesUniqueTau[[x]]],na.rm=T)*tau_int[x] })
+   
+  # ThermodynIntergal=lapply(2:length(uniqueTau),function(x){ (1/2)*(mean(mloglik_samples[indicesUniqueTau[[x]]],na.rm=T)+mean(mloglik_samples[indicesUniqueTau[[x-1]]],na.rm=T))*tau_int[x] })
+   
+   unThermDynInt=unlist(ThermodynIntergal)
+   unThermDynInt=unThermDynInt[which(!is.na(unThermDynInt))]
+   mllik[i]=sum(unThermDynInt)
+   
+ }
> 
> Savels=list(mllik=mllik,se=sd(mllik))
> save(Savels,file='savelist_allChains.RData')
> 
> 
> 
> 
> 
> 
> 
> #combine all the samples together
> 
> 
> tau_samples=list()
> mloglik_samples=list()
> 
> for (i in (1:10)){
+ out_ls=get(load(paste('mllik',i,'.RData',sep='')))
+ tau_samples[[i]]=c(out_ls$tau[low:up],rep(1,length(out_ls$tau[low:up])))
+ mloglik_samples[[i]]=c(out_ls$mllik[[1]][low:up],out_ls$mllik[[2]][low:up])
+ }
> 
> tau_samples       = unlist(tau_samples)
> mloglik_samples   = unlist(mloglik_samples)
> 
> indxSortedtau     = sort(tau_samples,index=T)
> 
> SortedThetaTau    = tau_samples[indxSortedtau$ix]
> 
> uniqueTau         = c(0,unique(SortedThetaTau))
> tau_int           = diff(uniqueTau)
> 
> 
> 
> 
> library(doParallel)
Loading required package: foreach
Loading required package: iterators
Loading required package: parallel
> cl <- makeCluster(4)
> registerDoParallel(cl)
> clusterCall(cl,function(x) {source('ST_Galaxy_functions.R');source('ST_Galaxy_runST.R')})
[[1]]
[[1]]$value
function (niter, data, k, Meanpriorpars, Sigmapriorpars, Ppriorpars, 
    nstops = 20, kptau, kp1, adps_k, adpm_k, equalVar = NULL) 
{
    data[78] = 26960
    y = data/1000
    n = length(y)
    means = list()
    means[[1]] = matrix(NA, niter, k)
    means[[2]] = matrix(NA, niter, k)
    means[[1]][1, ] = rep(20, k)
    means[[2]][1, ] = rep(20, k)
    sigma2 = list()
    if (is.null(equalVar)) {
        sigma2[[1]] = matrix(NA, niter, k)
        sigma2[[2]] = matrix(NA, niter, k)
        sigma2[[1]][1, ] = rep(0.5, k)
        sigma2[[2]][1, ] = rep(0.5, k)
    }
    else {
        sigma2[[1]] = matrix(NA, niter, 1)
        sigma2[[2]] = matrix(NA, niter, 1)
        sigma2[[1]][1] = 0.5
        sigma2[[2]][1] = 0.5
    }
    p = list()
    p[[1]] = matrix(NA, niter, k)
    p[[2]] = matrix(NA, niter, k)
    p[[1]][1, ] = rep(1/3, k)
    p[[2]][1, ] = rep(1/3, k)
    Z = list()
    tau = rep(NA, niter)
    tau[1] = 0.5
    mllik = list()
    mllik[[1]] = rep(NA, niter)
    mllik[[2]] = rep(NA, niter)
    tau_prop = rep(NA, niter)
    ptau = matrix(NA, niter, 2)
    kp = list()
    kp[[1]] = kp1
    kp[[2]] = kp1
    accm = list()
    accm[[1]] = matrix(1, nstops, k)
    accm[[2]] = matrix(1, nstops, k)
    accs = list()
    acc_rate = list()
    adps = list()
    if (is.null(equalVar)) {
        accs[[1]] = matrix(1, nstops, k)
        accs[[2]] = matrix(1, nstops, k)
        acc_rate[[1]] = matrix(1, nstops, k)
        acc_rate[[2]] = matrix(1, nstops, k)
        adps[[1]] = matrix(NA, niter, k)
        adps[[2]] = matrix(NA, niter, k)
        adps[[1]][1, ] = adps_k
        adps[[2]][1, ] = adps_k
    }
    else {
        accs[[1]] = rep(1, nstops)
        accs[[2]] = rep(1, nstops)
        acc_rate[[1]] = rep(1, nstops)
        acc_rate[[2]] = rep(1, nstops)
        adps[[1]] = rep(NA, niter)
        adps[[2]] = rep(NA, niter)
        adps[[1]][1] = adps_k
        adps[[2]][1] = adps_k
    }
    acc = rep(1, nstops)
    acc_rate1 = rep(1, nstops)
    acc_rate2 = list()
    acc_rate2[[1]] = matrix(1, nstops, k)
    acc_rate2[[2]] = matrix(1, nstops, k)
    adpm = list()
    adpm[[1]] = matrix(NA, niter, k)
    adpm[[2]] = matrix(NA, niter, k)
    adpm[[1]][1, ] = adpm_k
    adpm[[2]][1, ] = adpm_k
    tunetau = rep(NA, niter)
    tunetau[1] = 2
    beta = matrix(NA, niter, 2)
    beta[1, ] = c(tau[1], 1)
    npar = 2
    swappers = matrix(0, niter, 3)
    var_means = rep(NA, k)
    for (iter in (2:niter)) {
        maybeswap = sample(0:(npar + 1), 2, replace = TRUE)
        if (all(length(unique(maybeswap)) == 2, min(maybeswap) > 
            0, max(maybeswap) <= npar, iter > 2)) {
            if (is.null(equalVar)) {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1, ]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1, ]
            }
            else {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1]
            }
            l11 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[1]], k)$llik
            l22 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[2]], k)$llik
            l21 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[2]], k)$llik
            l12 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[1]], k)$llik
            if (runif(1) < exp(l12 + l21 - l11 - l22)) {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                }
                tmp = Z[[1]]
                Z[[1]] = Z[[2]]
                Z[[2]] = tmp
                swappers[iter, ] = c(sort(maybeswap), 1)
            }
            else {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                }
                swappers[iter, ] = c(sort(maybeswap), 0)
            }
            tau[iter] = tau[iter - 1]
            beta[iter, ] = beta[iter - 1, ]
        }
        else {
            chain = 1
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = tau[iter - 
                1], Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
            if (is.null(equalVar)) {
                sigma2_it1 = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_it1 = sigma2[[chain]][iter]
            }
            out1 = sample_tau(y = y, means = means[[chain]][iter, 
                ], sigma2 = sigma2_it1, p = p[[chain]][iter, 
                ], Meanpriorpars = Meanpriorpars, Sigmapriorpars = Sigmapriorpars, 
                k = k, tau = tau[iter - 1], Ppriorpars = Ppriorpars, 
                acc = acc[kptau], Z = Z[[chain]], tunetau = tunetau[iter - 
                  1], equalVar = equalVar)
            tau[iter] = out1$tau
            beta[iter, ] = c(tau[iter], 1)
            acc[kptau] = out1$acc
            tau_prop = out1$tau_prop
            ptau[iter, ] = out1$ptau
            chain = 2
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = 1, 
                Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                adps[[chain]][iter, ] = adps[[chain]][iter - 
                  1, ]
            }
            else {
                adps[[chain]][iter] = adps[[chain]][iter - 1]
            }
            adpm[[chain]][iter, ] = adpm[[chain]][iter - 1, ]
            if (iter == kp[[chain]][1] * niter/nstops) {
                if (is.null(equalVar)) {
                  acc_rate[[chain]][kp[[chain]][1], ] = (accs[[chain]][kp[[chain]][1], 
                    ] + 1)/(2 + (niter/nstops))
                }
                else {
                  acc_rate[[chain]][kp[[chain]][1]] = (accs[[chain]][kp[[chain]][1]] + 
                    1)/(2 + (niter/nstops))
                }
                kp[[chain]][1] = kp[[chain]][1] + 1
                if (iter < niter/2) {
                  if (is.null(equalVar)) {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1, 
                      ] > 0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1, ] < 0.19) {
                      adps[[chain]][iter, ] = adps[[chain]][iter, 
                        ] * acc_rate[[chain]][kp[[chain]][1] - 
                        1, ]/0.24
                    }
                  }
                  else {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1] > 
                      0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1] < 0.19) {
                      adps[[chain]][iter] = adps[[chain]][iter] * 
                        acc_rate[[chain]][kp[[chain]][1] - 1]/0.24
                    }
                  }
                }
            }
            if (iter == kp[[chain]][2] * niter/nstops) {
                acc_rate2[[chain]][kp[[chain]][2], ] = (accm[[chain]][kp[[chain]][2], 
                  ] + 1)/(2 + (niter/nstops))
                kp[[chain]][2] = kp[[chain]][2] + 1
                if (iter < niter/2) {
                  if (acc_rate2[[chain]][kp[[chain]][2] - 1, 
                    ] > 0.29 || acc_rate2[[chain]][kp[[chain]][2] - 
                    1, ] < 0.19) {
                    adpm[[chain]][iter, ] = adpm[[chain]][iter, 
                      ] * acc_rate2[[chain]][kp[[chain]][2] - 
                      1, ]/0.24
                  }
                }
            }
        }
        tunetau[iter] = tunetau[iter - 1]
        if (iter == kptau * niter/nstops) {
            acc_rate1[kptau] = (acc[kptau] + 1)/(2 + (niter/nstops))
            kptau = kptau + 1
            if (iter < niter/2) {
                if (acc_rate1[kptau - 1] > 0.19 || acc_rate1[kptau - 
                  1] < 0.9) {
                  tunetau[iter] = tunetau[iter] * acc_rate1[kptau - 
                    1]/0.14
                }
            }
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                sigma2_mllik = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_mllik = sigma2[[chain]][iter]
            }
            mllik[[chain]][iter] = loglike(y = y, Z = Z[[chain]], 
                p = p[[chain]][iter, ], means = means[[chain]][iter, 
                  ], sigma2 = sigma2_mllik, tau = tau[iter], 
                k = k)$mllik
        }
        if ((iter%%1000) == 0) {
            out_ls = list(means = means, sigma2 = sigma2, p = p, 
                Z = Z, accm = accm, accs = accs, tau = tau, acc = acc, 
                tau_prop = tau_prop, mllik = mllik, adps = adps, 
                tunetau = tunetau, acc_rate = acc_rate, acc_rate1 = acc_rate1, 
                acc_rate2 = acc_rate2, adpm = adpm, swappers = swappers)
            save(out_ls, file = paste("ST", iter, ".RData", sep = ""))
        }
    }
    return(list(means = means, sigma2 = sigma2, p = p, Z = Z, 
        accm = accm, accs = accs, tau = tau, acc = acc, tau_prop = tau_prop, 
        mllik = mllik, adps = adps, tunetau = tunetau, acc_rate = acc_rate, 
        acc_rate1 = acc_rate1, acc_rate2 = acc_rate2, adpm = adpm, 
        swappers = swappers))
}

[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
function (niter, data, k, Meanpriorpars, Sigmapriorpars, Ppriorpars, 
    nstops = 20, kptau, kp1, adps_k, adpm_k, equalVar = NULL) 
{
    data[78] = 26960
    y = data/1000
    n = length(y)
    means = list()
    means[[1]] = matrix(NA, niter, k)
    means[[2]] = matrix(NA, niter, k)
    means[[1]][1, ] = rep(20, k)
    means[[2]][1, ] = rep(20, k)
    sigma2 = list()
    if (is.null(equalVar)) {
        sigma2[[1]] = matrix(NA, niter, k)
        sigma2[[2]] = matrix(NA, niter, k)
        sigma2[[1]][1, ] = rep(0.5, k)
        sigma2[[2]][1, ] = rep(0.5, k)
    }
    else {
        sigma2[[1]] = matrix(NA, niter, 1)
        sigma2[[2]] = matrix(NA, niter, 1)
        sigma2[[1]][1] = 0.5
        sigma2[[2]][1] = 0.5
    }
    p = list()
    p[[1]] = matrix(NA, niter, k)
    p[[2]] = matrix(NA, niter, k)
    p[[1]][1, ] = rep(1/3, k)
    p[[2]][1, ] = rep(1/3, k)
    Z = list()
    tau = rep(NA, niter)
    tau[1] = 0.5
    mllik = list()
    mllik[[1]] = rep(NA, niter)
    mllik[[2]] = rep(NA, niter)
    tau_prop = rep(NA, niter)
    ptau = matrix(NA, niter, 2)
    kp = list()
    kp[[1]] = kp1
    kp[[2]] = kp1
    accm = list()
    accm[[1]] = matrix(1, nstops, k)
    accm[[2]] = matrix(1, nstops, k)
    accs = list()
    acc_rate = list()
    adps = list()
    if (is.null(equalVar)) {
        accs[[1]] = matrix(1, nstops, k)
        accs[[2]] = matrix(1, nstops, k)
        acc_rate[[1]] = matrix(1, nstops, k)
        acc_rate[[2]] = matrix(1, nstops, k)
        adps[[1]] = matrix(NA, niter, k)
        adps[[2]] = matrix(NA, niter, k)
        adps[[1]][1, ] = adps_k
        adps[[2]][1, ] = adps_k
    }
    else {
        accs[[1]] = rep(1, nstops)
        accs[[2]] = rep(1, nstops)
        acc_rate[[1]] = rep(1, nstops)
        acc_rate[[2]] = rep(1, nstops)
        adps[[1]] = rep(NA, niter)
        adps[[2]] = rep(NA, niter)
        adps[[1]][1] = adps_k
        adps[[2]][1] = adps_k
    }
    acc = rep(1, nstops)
    acc_rate1 = rep(1, nstops)
    acc_rate2 = list()
    acc_rate2[[1]] = matrix(1, nstops, k)
    acc_rate2[[2]] = matrix(1, nstops, k)
    adpm = list()
    adpm[[1]] = matrix(NA, niter, k)
    adpm[[2]] = matrix(NA, niter, k)
    adpm[[1]][1, ] = adpm_k
    adpm[[2]][1, ] = adpm_k
    tunetau = rep(NA, niter)
    tunetau[1] = 2
    beta = matrix(NA, niter, 2)
    beta[1, ] = c(tau[1], 1)
    npar = 2
    swappers = matrix(0, niter, 3)
    var_means = rep(NA, k)
    for (iter in (2:niter)) {
        maybeswap = sample(0:(npar + 1), 2, replace = TRUE)
        if (all(length(unique(maybeswap)) == 2, min(maybeswap) > 
            0, max(maybeswap) <= npar, iter > 2)) {
            if (is.null(equalVar)) {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1, ]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1, ]
            }
            else {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1]
            }
            l11 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[1]], k)$llik
            l22 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[2]], k)$llik
            l21 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[2]], k)$llik
            l12 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[1]], k)$llik
            if (runif(1) < exp(l12 + l21 - l11 - l22)) {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                }
                tmp = Z[[1]]
                Z[[1]] = Z[[2]]
                Z[[2]] = tmp
                swappers[iter, ] = c(sort(maybeswap), 1)
            }
            else {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                }
                swappers[iter, ] = c(sort(maybeswap), 0)
            }
            tau[iter] = tau[iter - 1]
            beta[iter, ] = beta[iter - 1, ]
        }
        else {
            chain = 1
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = tau[iter - 
                1], Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
            if (is.null(equalVar)) {
                sigma2_it1 = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_it1 = sigma2[[chain]][iter]
            }
            out1 = sample_tau(y = y, means = means[[chain]][iter, 
                ], sigma2 = sigma2_it1, p = p[[chain]][iter, 
                ], Meanpriorpars = Meanpriorpars, Sigmapriorpars = Sigmapriorpars, 
                k = k, tau = tau[iter - 1], Ppriorpars = Ppriorpars, 
                acc = acc[kptau], Z = Z[[chain]], tunetau = tunetau[iter - 
                  1], equalVar = equalVar)
            tau[iter] = out1$tau
            beta[iter, ] = c(tau[iter], 1)
            acc[kptau] = out1$acc
            tau_prop = out1$tau_prop
            ptau[iter, ] = out1$ptau
            chain = 2
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = 1, 
                Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                adps[[chain]][iter, ] = adps[[chain]][iter - 
                  1, ]
            }
            else {
                adps[[chain]][iter] = adps[[chain]][iter - 1]
            }
            adpm[[chain]][iter, ] = adpm[[chain]][iter - 1, ]
            if (iter == kp[[chain]][1] * niter/nstops) {
                if (is.null(equalVar)) {
                  acc_rate[[chain]][kp[[chain]][1], ] = (accs[[chain]][kp[[chain]][1], 
                    ] + 1)/(2 + (niter/nstops))
                }
                else {
                  acc_rate[[chain]][kp[[chain]][1]] = (accs[[chain]][kp[[chain]][1]] + 
                    1)/(2 + (niter/nstops))
                }
                kp[[chain]][1] = kp[[chain]][1] + 1
                if (iter < niter/2) {
                  if (is.null(equalVar)) {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1, 
                      ] > 0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1, ] < 0.19) {
                      adps[[chain]][iter, ] = adps[[chain]][iter, 
                        ] * acc_rate[[chain]][kp[[chain]][1] - 
                        1, ]/0.24
                    }
                  }
                  else {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1] > 
                      0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1] < 0.19) {
                      adps[[chain]][iter] = adps[[chain]][iter] * 
                        acc_rate[[chain]][kp[[chain]][1] - 1]/0.24
                    }
                  }
                }
            }
            if (iter == kp[[chain]][2] * niter/nstops) {
                acc_rate2[[chain]][kp[[chain]][2], ] = (accm[[chain]][kp[[chain]][2], 
                  ] + 1)/(2 + (niter/nstops))
                kp[[chain]][2] = kp[[chain]][2] + 1
                if (iter < niter/2) {
                  if (acc_rate2[[chain]][kp[[chain]][2] - 1, 
                    ] > 0.29 || acc_rate2[[chain]][kp[[chain]][2] - 
                    1, ] < 0.19) {
                    adpm[[chain]][iter, ] = adpm[[chain]][iter, 
                      ] * acc_rate2[[chain]][kp[[chain]][2] - 
                      1, ]/0.24
                  }
                }
            }
        }
        tunetau[iter] = tunetau[iter - 1]
        if (iter == kptau * niter/nstops) {
            acc_rate1[kptau] = (acc[kptau] + 1)/(2 + (niter/nstops))
            kptau = kptau + 1
            if (iter < niter/2) {
                if (acc_rate1[kptau - 1] > 0.19 || acc_rate1[kptau - 
                  1] < 0.9) {
                  tunetau[iter] = tunetau[iter] * acc_rate1[kptau - 
                    1]/0.14
                }
            }
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                sigma2_mllik = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_mllik = sigma2[[chain]][iter]
            }
            mllik[[chain]][iter] = loglike(y = y, Z = Z[[chain]], 
                p = p[[chain]][iter, ], means = means[[chain]][iter, 
                  ], sigma2 = sigma2_mllik, tau = tau[iter], 
                k = k)$mllik
        }
        if ((iter%%1000) == 0) {
            out_ls = list(means = means, sigma2 = sigma2, p = p, 
                Z = Z, accm = accm, accs = accs, tau = tau, acc = acc, 
                tau_prop = tau_prop, mllik = mllik, adps = adps, 
                tunetau = tunetau, acc_rate = acc_rate, acc_rate1 = acc_rate1, 
                acc_rate2 = acc_rate2, adpm = adpm, swappers = swappers)
            save(out_ls, file = paste("ST", iter, ".RData", sep = ""))
        }
    }
    return(list(means = means, sigma2 = sigma2, p = p, Z = Z, 
        accm = accm, accs = accs, tau = tau, acc = acc, tau_prop = tau_prop, 
        mllik = mllik, adps = adps, tunetau = tunetau, acc_rate = acc_rate, 
        acc_rate1 = acc_rate1, acc_rate2 = acc_rate2, adpm = adpm, 
        swappers = swappers))
}

[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
function (niter, data, k, Meanpriorpars, Sigmapriorpars, Ppriorpars, 
    nstops = 20, kptau, kp1, adps_k, adpm_k, equalVar = NULL) 
{
    data[78] = 26960
    y = data/1000
    n = length(y)
    means = list()
    means[[1]] = matrix(NA, niter, k)
    means[[2]] = matrix(NA, niter, k)
    means[[1]][1, ] = rep(20, k)
    means[[2]][1, ] = rep(20, k)
    sigma2 = list()
    if (is.null(equalVar)) {
        sigma2[[1]] = matrix(NA, niter, k)
        sigma2[[2]] = matrix(NA, niter, k)
        sigma2[[1]][1, ] = rep(0.5, k)
        sigma2[[2]][1, ] = rep(0.5, k)
    }
    else {
        sigma2[[1]] = matrix(NA, niter, 1)
        sigma2[[2]] = matrix(NA, niter, 1)
        sigma2[[1]][1] = 0.5
        sigma2[[2]][1] = 0.5
    }
    p = list()
    p[[1]] = matrix(NA, niter, k)
    p[[2]] = matrix(NA, niter, k)
    p[[1]][1, ] = rep(1/3, k)
    p[[2]][1, ] = rep(1/3, k)
    Z = list()
    tau = rep(NA, niter)
    tau[1] = 0.5
    mllik = list()
    mllik[[1]] = rep(NA, niter)
    mllik[[2]] = rep(NA, niter)
    tau_prop = rep(NA, niter)
    ptau = matrix(NA, niter, 2)
    kp = list()
    kp[[1]] = kp1
    kp[[2]] = kp1
    accm = list()
    accm[[1]] = matrix(1, nstops, k)
    accm[[2]] = matrix(1, nstops, k)
    accs = list()
    acc_rate = list()
    adps = list()
    if (is.null(equalVar)) {
        accs[[1]] = matrix(1, nstops, k)
        accs[[2]] = matrix(1, nstops, k)
        acc_rate[[1]] = matrix(1, nstops, k)
        acc_rate[[2]] = matrix(1, nstops, k)
        adps[[1]] = matrix(NA, niter, k)
        adps[[2]] = matrix(NA, niter, k)
        adps[[1]][1, ] = adps_k
        adps[[2]][1, ] = adps_k
    }
    else {
        accs[[1]] = rep(1, nstops)
        accs[[2]] = rep(1, nstops)
        acc_rate[[1]] = rep(1, nstops)
        acc_rate[[2]] = rep(1, nstops)
        adps[[1]] = rep(NA, niter)
        adps[[2]] = rep(NA, niter)
        adps[[1]][1] = adps_k
        adps[[2]][1] = adps_k
    }
    acc = rep(1, nstops)
    acc_rate1 = rep(1, nstops)
    acc_rate2 = list()
    acc_rate2[[1]] = matrix(1, nstops, k)
    acc_rate2[[2]] = matrix(1, nstops, k)
    adpm = list()
    adpm[[1]] = matrix(NA, niter, k)
    adpm[[2]] = matrix(NA, niter, k)
    adpm[[1]][1, ] = adpm_k
    adpm[[2]][1, ] = adpm_k
    tunetau = rep(NA, niter)
    tunetau[1] = 2
    beta = matrix(NA, niter, 2)
    beta[1, ] = c(tau[1], 1)
    npar = 2
    swappers = matrix(0, niter, 3)
    var_means = rep(NA, k)
    for (iter in (2:niter)) {
        maybeswap = sample(0:(npar + 1), 2, replace = TRUE)
        if (all(length(unique(maybeswap)) == 2, min(maybeswap) > 
            0, max(maybeswap) <= npar, iter > 2)) {
            if (is.null(equalVar)) {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1, ]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1, ]
            }
            else {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1]
            }
            l11 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[1]], k)$llik
            l22 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[2]], k)$llik
            l21 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[2]], k)$llik
            l12 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[1]], k)$llik
            if (runif(1) < exp(l12 + l21 - l11 - l22)) {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                }
                tmp = Z[[1]]
                Z[[1]] = Z[[2]]
                Z[[2]] = tmp
                swappers[iter, ] = c(sort(maybeswap), 1)
            }
            else {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                }
                swappers[iter, ] = c(sort(maybeswap), 0)
            }
            tau[iter] = tau[iter - 1]
            beta[iter, ] = beta[iter - 1, ]
        }
        else {
            chain = 1
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = tau[iter - 
                1], Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
            if (is.null(equalVar)) {
                sigma2_it1 = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_it1 = sigma2[[chain]][iter]
            }
            out1 = sample_tau(y = y, means = means[[chain]][iter, 
                ], sigma2 = sigma2_it1, p = p[[chain]][iter, 
                ], Meanpriorpars = Meanpriorpars, Sigmapriorpars = Sigmapriorpars, 
                k = k, tau = tau[iter - 1], Ppriorpars = Ppriorpars, 
                acc = acc[kptau], Z = Z[[chain]], tunetau = tunetau[iter - 
                  1], equalVar = equalVar)
            tau[iter] = out1$tau
            beta[iter, ] = c(tau[iter], 1)
            acc[kptau] = out1$acc
            tau_prop = out1$tau_prop
            ptau[iter, ] = out1$ptau
            chain = 2
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = 1, 
                Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                adps[[chain]][iter, ] = adps[[chain]][iter - 
                  1, ]
            }
            else {
                adps[[chain]][iter] = adps[[chain]][iter - 1]
            }
            adpm[[chain]][iter, ] = adpm[[chain]][iter - 1, ]
            if (iter == kp[[chain]][1] * niter/nstops) {
                if (is.null(equalVar)) {
                  acc_rate[[chain]][kp[[chain]][1], ] = (accs[[chain]][kp[[chain]][1], 
                    ] + 1)/(2 + (niter/nstops))
                }
                else {
                  acc_rate[[chain]][kp[[chain]][1]] = (accs[[chain]][kp[[chain]][1]] + 
                    1)/(2 + (niter/nstops))
                }
                kp[[chain]][1] = kp[[chain]][1] + 1
                if (iter < niter/2) {
                  if (is.null(equalVar)) {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1, 
                      ] > 0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1, ] < 0.19) {
                      adps[[chain]][iter, ] = adps[[chain]][iter, 
                        ] * acc_rate[[chain]][kp[[chain]][1] - 
                        1, ]/0.24
                    }
                  }
                  else {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1] > 
                      0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1] < 0.19) {
                      adps[[chain]][iter] = adps[[chain]][iter] * 
                        acc_rate[[chain]][kp[[chain]][1] - 1]/0.24
                    }
                  }
                }
            }
            if (iter == kp[[chain]][2] * niter/nstops) {
                acc_rate2[[chain]][kp[[chain]][2], ] = (accm[[chain]][kp[[chain]][2], 
                  ] + 1)/(2 + (niter/nstops))
                kp[[chain]][2] = kp[[chain]][2] + 1
                if (iter < niter/2) {
                  if (acc_rate2[[chain]][kp[[chain]][2] - 1, 
                    ] > 0.29 || acc_rate2[[chain]][kp[[chain]][2] - 
                    1, ] < 0.19) {
                    adpm[[chain]][iter, ] = adpm[[chain]][iter, 
                      ] * acc_rate2[[chain]][kp[[chain]][2] - 
                      1, ]/0.24
                  }
                }
            }
        }
        tunetau[iter] = tunetau[iter - 1]
        if (iter == kptau * niter/nstops) {
            acc_rate1[kptau] = (acc[kptau] + 1)/(2 + (niter/nstops))
            kptau = kptau + 1
            if (iter < niter/2) {
                if (acc_rate1[kptau - 1] > 0.19 || acc_rate1[kptau - 
                  1] < 0.9) {
                  tunetau[iter] = tunetau[iter] * acc_rate1[kptau - 
                    1]/0.14
                }
            }
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                sigma2_mllik = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_mllik = sigma2[[chain]][iter]
            }
            mllik[[chain]][iter] = loglike(y = y, Z = Z[[chain]], 
                p = p[[chain]][iter, ], means = means[[chain]][iter, 
                  ], sigma2 = sigma2_mllik, tau = tau[iter], 
                k = k)$mllik
        }
        if ((iter%%1000) == 0) {
            out_ls = list(means = means, sigma2 = sigma2, p = p, 
                Z = Z, accm = accm, accs = accs, tau = tau, acc = acc, 
                tau_prop = tau_prop, mllik = mllik, adps = adps, 
                tunetau = tunetau, acc_rate = acc_rate, acc_rate1 = acc_rate1, 
                acc_rate2 = acc_rate2, adpm = adpm, swappers = swappers)
            save(out_ls, file = paste("ST", iter, ".RData", sep = ""))
        }
    }
    return(list(means = means, sigma2 = sigma2, p = p, Z = Z, 
        accm = accm, accs = accs, tau = tau, acc = acc, tau_prop = tau_prop, 
        mllik = mllik, adps = adps, tunetau = tunetau, acc_rate = acc_rate, 
        acc_rate1 = acc_rate1, acc_rate2 = acc_rate2, adpm = adpm, 
        swappers = swappers))
}

[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
function (niter, data, k, Meanpriorpars, Sigmapriorpars, Ppriorpars, 
    nstops = 20, kptau, kp1, adps_k, adpm_k, equalVar = NULL) 
{
    data[78] = 26960
    y = data/1000
    n = length(y)
    means = list()
    means[[1]] = matrix(NA, niter, k)
    means[[2]] = matrix(NA, niter, k)
    means[[1]][1, ] = rep(20, k)
    means[[2]][1, ] = rep(20, k)
    sigma2 = list()
    if (is.null(equalVar)) {
        sigma2[[1]] = matrix(NA, niter, k)
        sigma2[[2]] = matrix(NA, niter, k)
        sigma2[[1]][1, ] = rep(0.5, k)
        sigma2[[2]][1, ] = rep(0.5, k)
    }
    else {
        sigma2[[1]] = matrix(NA, niter, 1)
        sigma2[[2]] = matrix(NA, niter, 1)
        sigma2[[1]][1] = 0.5
        sigma2[[2]][1] = 0.5
    }
    p = list()
    p[[1]] = matrix(NA, niter, k)
    p[[2]] = matrix(NA, niter, k)
    p[[1]][1, ] = rep(1/3, k)
    p[[2]][1, ] = rep(1/3, k)
    Z = list()
    tau = rep(NA, niter)
    tau[1] = 0.5
    mllik = list()
    mllik[[1]] = rep(NA, niter)
    mllik[[2]] = rep(NA, niter)
    tau_prop = rep(NA, niter)
    ptau = matrix(NA, niter, 2)
    kp = list()
    kp[[1]] = kp1
    kp[[2]] = kp1
    accm = list()
    accm[[1]] = matrix(1, nstops, k)
    accm[[2]] = matrix(1, nstops, k)
    accs = list()
    acc_rate = list()
    adps = list()
    if (is.null(equalVar)) {
        accs[[1]] = matrix(1, nstops, k)
        accs[[2]] = matrix(1, nstops, k)
        acc_rate[[1]] = matrix(1, nstops, k)
        acc_rate[[2]] = matrix(1, nstops, k)
        adps[[1]] = matrix(NA, niter, k)
        adps[[2]] = matrix(NA, niter, k)
        adps[[1]][1, ] = adps_k
        adps[[2]][1, ] = adps_k
    }
    else {
        accs[[1]] = rep(1, nstops)
        accs[[2]] = rep(1, nstops)
        acc_rate[[1]] = rep(1, nstops)
        acc_rate[[2]] = rep(1, nstops)
        adps[[1]] = rep(NA, niter)
        adps[[2]] = rep(NA, niter)
        adps[[1]][1] = adps_k
        adps[[2]][1] = adps_k
    }
    acc = rep(1, nstops)
    acc_rate1 = rep(1, nstops)
    acc_rate2 = list()
    acc_rate2[[1]] = matrix(1, nstops, k)
    acc_rate2[[2]] = matrix(1, nstops, k)
    adpm = list()
    adpm[[1]] = matrix(NA, niter, k)
    adpm[[2]] = matrix(NA, niter, k)
    adpm[[1]][1, ] = adpm_k
    adpm[[2]][1, ] = adpm_k
    tunetau = rep(NA, niter)
    tunetau[1] = 2
    beta = matrix(NA, niter, 2)
    beta[1, ] = c(tau[1], 1)
    npar = 2
    swappers = matrix(0, niter, 3)
    var_means = rep(NA, k)
    for (iter in (2:niter)) {
        maybeswap = sample(0:(npar + 1), 2, replace = TRUE)
        if (all(length(unique(maybeswap)) == 2, min(maybeswap) > 
            0, max(maybeswap) <= npar, iter > 2)) {
            if (is.null(equalVar)) {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1, ]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1, ]
            }
            else {
                sigma2_1 = sigma2[[maybeswap[1]]][iter - 1]
                sigma2_2 = sigma2[[maybeswap[2]]][iter - 1]
            }
            l11 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[1]], k)$llik
            l22 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[2]], k)$llik
            l21 = loglike(y, Z[[maybeswap[1]]], p[[maybeswap[1]]][iter - 
                1, ], means[[maybeswap[1]]][iter - 1, ], sigma2_1, 
                beta[maybeswap[2]], k)$llik
            l12 = loglike(y, Z[[maybeswap[2]]], p[[maybeswap[2]]][iter - 
                1, ], means[[maybeswap[2]]][iter - 1, ], sigma2_2, 
                beta[maybeswap[1]], k)$llik
            if (runif(1) < exp(l12 + l21 - l11 - l22)) {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                }
                tmp = Z[[1]]
                Z[[1]] = Z[[2]]
                Z[[2]] = tmp
                swappers[iter, ] = c(sort(maybeswap), 1)
            }
            else {
                means[[maybeswap[1]]][iter, ] = means[[maybeswap[1]]][iter - 
                  1, ]
                p[[maybeswap[1]]][iter, ] = p[[maybeswap[1]]][iter - 
                  1, ]
                means[[maybeswap[2]]][iter, ] = means[[maybeswap[2]]][iter - 
                  1, ]
                p[[maybeswap[2]]][iter, ] = p[[maybeswap[2]]][iter - 
                  1, ]
                if (is.null(equalVar)) {
                  sigma2[[maybeswap[1]]][iter, ] = sigma2[[maybeswap[1]]][iter - 
                    1, ]
                  sigma2[[maybeswap[2]]][iter, ] = sigma2[[maybeswap[2]]][iter - 
                    1, ]
                }
                else {
                  sigma2[[maybeswap[1]]][iter] = sigma2[[maybeswap[1]]][iter - 
                    1]
                  sigma2[[maybeswap[2]]][iter] = sigma2[[maybeswap[2]]][iter - 
                    1]
                }
                swappers[iter, ] = c(sort(maybeswap), 0)
            }
            tau[iter] = tau[iter - 1]
            beta[iter, ] = beta[iter - 1, ]
        }
        else {
            chain = 1
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = tau[iter - 
                1], Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
            if (is.null(equalVar)) {
                sigma2_it1 = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_it1 = sigma2[[chain]][iter]
            }
            out1 = sample_tau(y = y, means = means[[chain]][iter, 
                ], sigma2 = sigma2_it1, p = p[[chain]][iter, 
                ], Meanpriorpars = Meanpriorpars, Sigmapriorpars = Sigmapriorpars, 
                k = k, tau = tau[iter - 1], Ppriorpars = Ppriorpars, 
                acc = acc[kptau], Z = Z[[chain]], tunetau = tunetau[iter - 
                  1], equalVar = equalVar)
            tau[iter] = out1$tau
            beta[iter, ] = c(tau[iter], 1)
            acc[kptau] = out1$acc
            tau_prop = out1$tau_prop
            ptau[iter, ] = out1$ptau
            chain = 2
            if (is.null(equalVar)) {
                sigma2_it = sigma2[[chain]][iter - 1, ]
                accs_it = accs[[chain]][kp[[chain]][1], ]
                adps_it = adps[[chain]][iter - 1, ]
            }
            else {
                sigma2_it = sigma2[[chain]][iter - 1]
                accs_it = accs[[chain]][kp[[chain]][1]]
                adps_it = adps[[chain]][iter - 1]
            }
            out = Gibbs(y = y, means = means[[chain]][iter - 
                1, ], sigma2 = sigma2_it, p = p[[chain]][iter - 
                1, ], Meanpriorpars = Meanpriorpars, tau = 1, 
                Sigmapriorpars = Sigmapriorpars, Ppriorpars = Ppriorpars, 
                accm = accm[[chain]][kp[[chain]][2], ], accs = accs_it, 
                k = k, adps = adps_it, adpm = adpm[[chain]][iter - 
                  1, ], equalVar = equalVar)
            means[[chain]][iter, ] = out$means
            if (is.null(equalVar)) {
                sigma2[[chain]][iter, ] = out$sigma2
                accs[[chain]][kp[[chain]][1], ] = out$accs
            }
            else {
                sigma2[[chain]][iter] = out$sigma2
                accs[[chain]][kp[[chain]][1]] = out$accs
            }
            p[[chain]][iter, ] = out$p
            Z[[chain]] = out$Z
            accm[[chain]][kp[[chain]][2], ] = out$accm
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                adps[[chain]][iter, ] = adps[[chain]][iter - 
                  1, ]
            }
            else {
                adps[[chain]][iter] = adps[[chain]][iter - 1]
            }
            adpm[[chain]][iter, ] = adpm[[chain]][iter - 1, ]
            if (iter == kp[[chain]][1] * niter/nstops) {
                if (is.null(equalVar)) {
                  acc_rate[[chain]][kp[[chain]][1], ] = (accs[[chain]][kp[[chain]][1], 
                    ] + 1)/(2 + (niter/nstops))
                }
                else {
                  acc_rate[[chain]][kp[[chain]][1]] = (accs[[chain]][kp[[chain]][1]] + 
                    1)/(2 + (niter/nstops))
                }
                kp[[chain]][1] = kp[[chain]][1] + 1
                if (iter < niter/2) {
                  if (is.null(equalVar)) {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1, 
                      ] > 0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1, ] < 0.19) {
                      adps[[chain]][iter, ] = adps[[chain]][iter, 
                        ] * acc_rate[[chain]][kp[[chain]][1] - 
                        1, ]/0.24
                    }
                  }
                  else {
                    if (acc_rate[[chain]][kp[[chain]][1] - 1] > 
                      0.29 || acc_rate[[chain]][kp[[chain]][1] - 
                      1] < 0.19) {
                      adps[[chain]][iter] = adps[[chain]][iter] * 
                        acc_rate[[chain]][kp[[chain]][1] - 1]/0.24
                    }
                  }
                }
            }
            if (iter == kp[[chain]][2] * niter/nstops) {
                acc_rate2[[chain]][kp[[chain]][2], ] = (accm[[chain]][kp[[chain]][2], 
                  ] + 1)/(2 + (niter/nstops))
                kp[[chain]][2] = kp[[chain]][2] + 1
                if (iter < niter/2) {
                  if (acc_rate2[[chain]][kp[[chain]][2] - 1, 
                    ] > 0.29 || acc_rate2[[chain]][kp[[chain]][2] - 
                    1, ] < 0.19) {
                    adpm[[chain]][iter, ] = adpm[[chain]][iter, 
                      ] * acc_rate2[[chain]][kp[[chain]][2] - 
                      1, ]/0.24
                  }
                }
            }
        }
        tunetau[iter] = tunetau[iter - 1]
        if (iter == kptau * niter/nstops) {
            acc_rate1[kptau] = (acc[kptau] + 1)/(2 + (niter/nstops))
            kptau = kptau + 1
            if (iter < niter/2) {
                if (acc_rate1[kptau - 1] > 0.19 || acc_rate1[kptau - 
                  1] < 0.9) {
                  tunetau[iter] = tunetau[iter] * acc_rate1[kptau - 
                    1]/0.14
                }
            }
        }
        for (chain in (1:npar)) {
            if (is.null(equalVar)) {
                sigma2_mllik = sigma2[[chain]][iter, ]
            }
            else {
                sigma2_mllik = sigma2[[chain]][iter]
            }
            mllik[[chain]][iter] = loglike(y = y, Z = Z[[chain]], 
                p = p[[chain]][iter, ], means = means[[chain]][iter, 
                  ], sigma2 = sigma2_mllik, tau = tau[iter], 
                k = k)$mllik
        }
        if ((iter%%1000) == 0) {
            out_ls = list(means = means, sigma2 = sigma2, p = p, 
                Z = Z, accm = accm, accs = accs, tau = tau, acc = acc, 
                tau_prop = tau_prop, mllik = mllik, adps = adps, 
                tunetau = tunetau, acc_rate = acc_rate, acc_rate1 = acc_rate1, 
                acc_rate2 = acc_rate2, adpm = adpm, swappers = swappers)
            save(out_ls, file = paste("ST", iter, ".RData", sep = ""))
        }
    }
    return(list(means = means, sigma2 = sigma2, p = p, Z = Z, 
        accm = accm, accs = accs, tau = tau, acc = acc, tau_prop = tau_prop, 
        mllik = mllik, adps = adps, tunetau = tunetau, acc_rate = acc_rate, 
        acc_rate1 = acc_rate1, acc_rate2 = acc_rate2, adpm = adpm, 
        swappers = swappers))
}

[[4]]$visible
[1] FALSE


> clusterExport(cl,varlist=ls())
> 
> indicesUniqueTau  = parLapply(cl,1:length(uniqueTau),function(x){ which(tau_samples==uniqueTau[x]) })
> stopCluster(cl)
> 
> ThermodynIntergal = lapply(1:length(uniqueTau),function(x){ mean(mloglik_samples[indicesUniqueTau[[x]]],na.rm=T)*tau_int[x] })
> 
> #ThermodynIntergal=lapply(2:length(uniqueTau),function(x){ (1/2)*(mean(mloglik_samples[indicesUniqueTau[[x]]],na.rm=T)+mean(mloglik_samples[indicesUniqueTau[[x-1]]],na.rm=T))*tau_int[x] })
> 
> unThermDynInt     = unlist(ThermodynIntergal)
> unThermDynInt     = unThermDynInt[which(!is.na(unThermDynInt))]
> mllik             = sum(unThermDynInt)
> 
> save(mllik,file='AllSamplesCombined_allChains.RData')
> 
> proc.time()
   user  system elapsed 
  9.615   2.159  30.900 
